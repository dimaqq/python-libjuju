# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client._definitions import *
from juju.client.facade import ReturnMapping, Type


class AllModelWatcherFacade(Type):
    name = "AllModelWatcher"
    version = 4

    @ReturnMapping(AllWatcherNextResults)
    async def Next(self):
        """Next will return the current state of everything on the first call
        and subsequent calls will

        Returns -> AllWatcherNextResults
        """
        # map input types to rpc msg
        _params = dict()
        msg = dict(type="AllModelWatcher", request="Next", version=4, params=_params)

        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(None)
    async def Stop(self):
        """Stop stops the watcher.

        Returns -> None
        """
        # map input types to rpc msg
        _params = dict()
        msg = dict(type="AllModelWatcher", request="Stop", version=4, params=_params)

        reply = await self.rpc(msg)
        return reply

    async def rpc(self, msg):
        """Patch rpc method to add Id."""
        if not hasattr(self, "Id"):
            raise RuntimeError('Missing "Id" field')
        msg["Id"] = id

        from .facade import TypeEncoder

        reply = await self.connection.rpc(msg, encoder=TypeEncoder)
        return reply


class ModelGenerationFacade(Type):
    name = "ModelGeneration"
    version = 4

    @ReturnMapping(ErrorResult)
    async def AbortBranch(self, branch=None):
        """AbortBranch aborts the input branch, marking it complete.  However no
        changes are made applicable to the whole model.  No units may be assigned
        to the branch when aborting.

        branch : str
        Returns -> ErrorResult
        """
        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception(f"Expected branch to be a str, received: {type(branch)}")

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="AbortBranch", version=4, params=_params
        )
        _params["branch"] = branch
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(ErrorResult)
    async def AddBranch(self, branch=None):
        """AddBranch adds a new branch with the input name to the model.

        branch : str
        Returns -> ErrorResult
        """
        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception(f"Expected branch to be a str, received: {type(branch)}")

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="AddBranch", version=4, params=_params
        )
        _params["branch"] = branch
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(BranchResults)
    async def BranchInfo(self, branches=None, detailed=None):
        """BranchInfo will return details of branch identified by the input argument,
        including units on the branch and the configuration disjoint with the
        master generation.
        An error is returned if no in-flight branch matching in input is found.

        branches : typing.Sequence[str]
        detailed : bool
        Returns -> BranchResults
        """
        if branches is not None and not isinstance(branches, (bytes, str, list)):
            raise Exception(
                f"Expected branches to be a Sequence, received: {type(branches)}"
            )

        if detailed is not None and not isinstance(detailed, bool):
            raise Exception(
                f"Expected detailed to be a bool, received: {type(detailed)}"
            )

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="BranchInfo", version=4, params=_params
        )
        _params["branches"] = branches
        _params["detailed"] = detailed
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(IntResult)
    async def CommitBranch(self, branch=None):
        """CommitBranch commits the input branch, making its changes applicable to
        the whole model and marking it complete.

        branch : str
        Returns -> IntResult
        """
        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception(f"Expected branch to be a str, received: {type(branch)}")

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="CommitBranch", version=4, params=_params
        )
        _params["branch"] = branch
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(BoolResult)
    async def HasActiveBranch(self, branch=None):
        """HasActiveBranch returns a true result if the input model has an "in-flight"
        branch matching the input name.

        branch : str
        Returns -> BoolResult
        """
        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception(f"Expected branch to be a str, received: {type(branch)}")

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="HasActiveBranch", version=4, params=_params
        )
        _params["branch"] = branch
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(BranchResults)
    async def ListCommits(self):
        """ListCommits will return the commits, hence only branches with generation_id higher than 0

        Returns -> BranchResults
        """
        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="ListCommits", version=4, params=_params
        )

        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(GenerationResult)
    async def ShowCommit(self, generation_id=None):
        """ShowCommit will return details a commit given by its generationId
        An error is returned if either no branch can be found corresponding to the generation id.
        Or the generation id given is below 1.

        generation_id : int
        Returns -> GenerationResult
        """
        if generation_id is not None and not isinstance(generation_id, int):
            raise Exception(
                f"Expected generation_id to be a int, received: {type(generation_id)}"
            )

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="ShowCommit", version=4, params=_params
        )
        _params["generation-id"] = generation_id
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(ErrorResults)
    async def TrackBranch(self, branch=None, entities=None, num_units=None):
        """TrackBranch marks the input units and/or applications as tracking the input
        branch, causing them to realise changes made under that branch.

        branch : str
        entities : typing.Sequence[~Entity]
        num_units : int
        Returns -> ErrorResults
        """
        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception(f"Expected branch to be a str, received: {type(branch)}")

        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception(
                f"Expected entities to be a Sequence, received: {type(entities)}"
            )

        if num_units is not None and not isinstance(num_units, int):
            raise Exception(
                f"Expected num_units to be a int, received: {type(num_units)}"
            )

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="ModelGeneration", request="TrackBranch", version=4, params=_params
        )
        _params["branch"] = branch
        _params["entities"] = entities
        _params["num-units"] = num_units
        reply = await self.rpc(msg)
        return reply


class SSHClientFacade(Type):
    name = "SSHClient"
    version = 4

    @ReturnMapping(SSHAddressesResults)
    async def AllAddresses(self, entities=None):
        """AllAddresses reports all addresses that might have SSH listening for each
        entity in args. The result is sorted with public addresses first.
        Machines and units are supported as entity types.

        entities : typing.Sequence[~Entity]
        Returns -> SSHAddressesResults
        """
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception(
                f"Expected entities to be a Sequence, received: {type(entities)}"
            )

        # map input types to rpc msg
        _params = dict()
        msg = dict(type="SSHClient", request="AllAddresses", version=4, params=_params)
        _params["entities"] = entities
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(CloudSpecResult)
    async def ModelCredentialForSSH(self):
        """ModelCredentialForSSH returns a cloud spec for ssh purpose.
        This facade call is only used for k8s model.

        Returns -> CloudSpecResult
        """
        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="SSHClient", request="ModelCredentialForSSH", version=4, params=_params
        )

        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(SSHAddressResults)
    async def PrivateAddress(self, entities=None):
        """PrivateAddress reports the preferred private network address for one or
        more entities. Machines and units are supported.

        entities : typing.Sequence[~Entity]
        Returns -> SSHAddressResults
        """
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception(
                f"Expected entities to be a Sequence, received: {type(entities)}"
            )

        # map input types to rpc msg
        _params = dict()
        msg = dict(
            type="SSHClient", request="PrivateAddress", version=4, params=_params
        )
        _params["entities"] = entities
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(SSHProxyResult)
    async def Proxy(self):
        """Proxy returns whether SSH connections should be proxied through the
        controller hosts for the model associated with the API connection.

        Returns -> SSHProxyResult
        """
        # map input types to rpc msg
        _params = dict()
        msg = dict(type="SSHClient", request="Proxy", version=4, params=_params)

        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(SSHAddressResults)
    async def PublicAddress(self, entities=None):
        """PublicAddress reports the preferred public network address for one
        or more entities. Machines and units are supported.

        entities : typing.Sequence[~Entity]
        Returns -> SSHAddressResults
        """
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception(
                f"Expected entities to be a Sequence, received: {type(entities)}"
            )

        # map input types to rpc msg
        _params = dict()
        msg = dict(type="SSHClient", request="PublicAddress", version=4, params=_params)
        _params["entities"] = entities
        reply = await self.rpc(msg)
        return reply

    @ReturnMapping(SSHPublicKeysResults)
    async def PublicKeys(self, entities=None):
        """PublicKeys returns the public SSH hosts for one or more
        entities. Machines and units are supported.

        entities : typing.Sequence[~Entity]
        Returns -> SSHPublicKeysResults
        """
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception(
                f"Expected entities to be a Sequence, received: {type(entities)}"
            )

        # map input types to rpc msg
        _params = dict()
        msg = dict(type="SSHClient", request="PublicKeys", version=4, params=_params)
        _params["entities"] = entities
        reply = await self.rpc(msg)
        return reply
